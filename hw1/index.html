<html>
	<head>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=default'></script>
		<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
		<style>
			h1 {
				text-align: center;
			}

			.container {
				margin: 0 auto;
				padding: 60px 20%;
			}

			figure {
				text-align: center;
			}

			img {
				display: inline-block;
			}

			body {
				font-family: 'Inter', sans-serif;
			}
		</style>
	</head>
	<body>
		<div class="container">
		<h1>CS184/284A Spring 2025 Homework 1 Write-Up</h1>
		<div style="text-align: center;">Yimeng Li and Luca Herden</div>

		<br>

		Link to webpage: (TODO) <a href="https://cal-cs184-student.github.io/hw-webpages-JustNoo/hw1/index.html">Webpage</a>
		
		<br>

		Link to GitHub repository: (TODO) <a href="https://github.com/cal-cs184-student/hw1-rasterizer-timing">Repo</a>

		<figure>
			<img src="lion.jpg" alt="Lion" style="width:50%"/>
			<figcaption>You can add images with captions!</figcaption>
		</figure>

		<!--
		We've already added one heading per task, to make your write-up as navigable when grading. Please fit your write-up within these sections!
		-->

		<h2>Overview</h2>
		Give a high-level overview of what you implemented in this homework. Think about what you've built as a whole. Share your thoughts on what interesting things you've learned from completing the homework.

		<h2>Task 1: Drawing Single-Color Triangles</h2>
		To rasterize a triangle, I first calculate a bounding box by finding the minimum and maximum x and y coordinates of its vertices. I iterate through every pixel in this box, sampling at the center (x+0.5,y+0.5). For each sample, I apply three line equations to check if the point lies on the same side of all edges. If the point is inside, regardless of vertex winding order, I fill the corresponding pixel.

		This algorithm is as efficient as any bounding box sampler because it strictly limits its search space to the smallest rectangle enclosing the triangle. By setting the loop boundaries to the vertex extremes, the code avoids testing any pixels globally across the framebuffer. It performs the minimum necessary point-in-triangle tests to ensure full coverage without wasting cycles on pixels guaranteed to be outside the triangle’s immediate area.

		For the extra credit, I implemented Incremental Triangle Traversal to optimize the rasterization loop. In the basic implementation, the line equation \[ L(x,y) = -(x - X_i)dY_i + (y - Y_i)dX_i \] is recomputed for every pixel, requiring expensive floating--point multiplications. Observing that the line equation is linear, I factored these redundant operations out of the inner loop. When moving from \((x,y) \) to \( (x+1,y) )\, the value changes by a constant \( -dY_i$ \), and moving to the next row changes it by \( +dX_i \). By precomputing these edge derivatives and the initial values at the bounding box corner, the per--pixel work reduces to only three additions, significantly lowering CPU cycles and accelerating the rasterization process.
		<p>Here is an example 2x2 gridlike structure using an HTML table. Each <b>tr</b> is a row and each <b>td</b> is a column in that row. You might find this useful for framing and showing your result images in an organized fashion.</p>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<img src="t1.jpg" width="400px"/>
				  <figcaption>basic/test4.svg</figcaption>
		</div>
		
		<h2>Task 2: Antialiasing by Supersampling</h2>
		To implement supersampling, I expanded the 1D \texttt{sample\_buffer} vector to store \texttt{sample\_rate} sub--samples per pixel and modified \texttt{rasterize\_triangle} to test coverage across a sub--pixel grid. This technique combats jaggies by evaluating the fractional coverage of each pixel, producing visually smoother edges. Supporting this required several pipeline changes: updating memory allocation and clearing functions, adapting \texttt{fill\_pixel} to color all sub--samples identically for points and lines, and introducing a final \texttt{resolve\_to\_framebuffer} step. During this resolution phase, the algorithm downsamples the high--resolution internal buffer by averaging the RGB values of all sub--samples within each target pixel, effectively blending triangle and background colors to produce smooth, antialiased edges in the final display.

		<h2>Task 3: Transforms</h2>
		For this task, I changed the cubeman from a static pose to a running-and-waving pose. I used nested translate, rotate, and scale transforms to bend the arms and legs, tilt the torso and head, and create asymmetry so it looks like motion. I also changed colors and proportions to make each body part clearer and the design more expressive.

		<h2>Task 4: Barycentric coordinates</h2>
		Barycentric coordinates are a special type of coordinates used to describe any point inside of a triangle as a weighted combination of the triangle’s vertices. Suppose a triangle has vertices A, B, and C. Its barycentric coordinates can be written as (a, b, y), and (x, y) = (formula), with a + b + y = 1. This allows for interpolation of the vertices of the triangle, and creates proportional areas within the triangle for every point placed. This effect is visible in the color triangle shown below, in which each vertex has a different color, and they are blended together seamlessly inside the triangle. Any point selected in the triangle can thus be visually separated into barycentric coordinates, or a linear combination of the three vertex colors. 

		<h2>Task 5: "Pixel sampling" for texture mapping</h2>
		Pixel sampling can best be simply described as the step that decides the color of each pixel based on the overall texture the image being rendered. More specifically, it takes a continuous texture coordinate (u, v), and then chooses the correct texel color to use from the image at each pixel’s location. It is the active step in the process of texture mapping, which projects a 2D image, or texture, onto a 3D surface. The two methods of pixel sampling used here are nearest-neighbor and bilinear sampling, which differ as the name suggests – nearest-neighbor picks the texel closest to the location of (u, v), while bilinear takes the average of the four nearest texels. Bilinear thus provides a generally smoother result than nearest-neighbor, at the cost of being slightly more computationally expensive. This difference is accordingly most visible when the picture is zoomed in, as nearest-neighbor appears more pixelated as seen in the comparison below (even with fewer pixel samples!). 
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="lion.jpg" width="400px"/>
				  <figcaption>Caption goes here.</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="lion.jpg" width="400px"/>
				  <figcaption>Caption goes here.</figcaption>
				</td>
			  </tr>
			  <tr>
				<td style="text-align: center;">
				  <img src="lion.jpg" width="400px"/>
				  <figcaption>Caption goes here.</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="lion.jpg" width="400px"/>
				  <figcaption>Caption goes here.</figcaption>
				</td>
			  </tr>
			</table>
		</div>

		<h2>Task 6: "Level Sampling" with mipmaps for texture mapping</h2>
		Level sampling decides which resolution, or mipmap level, of the texture to sample from. While always sampling the highest resolution might seem appealing, this may result in aliasing artifacts from the sampled pixels being too far apart. With level sampling, a lower resolution image that better matches the size of the sample can be used instead, thus reducing artifacts and improving image quality. In the implementation, we first estimated the appropriate mip level by estimating pixel size with uv derivatives, or how much uv changes when moving in each direction, and multiplying by the general dimensions to get an overall estimate. From there, we can use either pixel sampling, level sampling, or supersampling. As mentioned in the previous task, pixel sampling is the “default” least computationally intensive option, while level sampling here uses a bit more power but reduces artifacts, and supersampling is the most expensive and most antialiased. 
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="lion.jpg" width="400px"/>
				  <figcaption>Caption goes here.</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="lion.jpg" width="400px"/>
				  <figcaption>Caption goes here.</figcaption>
				</td>
			  </tr>
			  <tr>
				<td style="text-align: center;">
				  <img src="lion.jpg" width="400px"/>
				  <figcaption>Caption goes here.</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="lion.jpg" width="400px"/>
				  <figcaption>Caption goes here.</figcaption>
				</td>
			  </tr>
			</table>
		</div>

		<h2>Additional Notes (please remove)</h2>
		<ul>
			<li>You can also add code if you'd like as so: <code>code code code</code></li>
			<li>If you'd like to add math equations, 
				<ul>
					<li>You can write inline equations like so: \( a^2 + b^2 = c^2 \)</li>
					<li>You can write display equations like so: \[ a^2 + b^2 = c^2 \]</li>
				</ul>
			</li>
		</ul>
		</div>
	</body>
</html>